package scripts;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;


public class DirectoryToText {
	
	// Method to generate the formatting rules string
	private static String getFormattingRules() {
		StringBuilder rules = new StringBuilder();
		rules.append("--- DIRECTORY SCANNER FORMATTING RULES ---\n");
		rules.append("Defination of those rules and with a line of \"-\" and 2 new lines.\n");
		rules.append("This file was generated by the DirectoryToText utility.\n");
		rules.append("Which stores all of the text data of a folder and it's all subpaths in this file without missing any content.\n");
		rules.append("Each line is prefixed with a 4-character code indicating its type:\n");
		rules.append("(Note: Each line Execpt for the Text line is also prefixed with the same code after the identation for extra clarity:\n");
		rules.append(LineType.DIRECTORY_NAME.getPrefix()).append(" : Directory Name (e.g., 'DN: MyFolder:')\n");
		rules.append(LineType.FILE_NAME.getPrefix()).append(" : File Name (e.g., 'FN: MyTextFile.txt:') or Non-Text File Name (e.g., 'FN: MyImage.png;')\n");
		rules.append(LineType.TEXT.getPrefix()).append("  : Text Content Line (e.g., 'TL  This is a line of text.')\n");
		rules.append(LineType.FILE_END.getPrefix()).append(" : End of File Marker (e.g., 'Fend')\n");
		rules.append(LineType.DIRECTORY_END.getPrefix()).append(" : End of Directory Marker (e.g., 'Dend')\n");
		rules.append("\nNotes:\n");
		rules.append("  - Directory and text file names end with ':' for identification.\n");
		rules.append("  - Non-text file names end with ';' for identification.\n");
		rules.append("  - Content lines (TL) are indented with a tab.\n");
		rules.append("  - Non-text files do not have content lines, only name and end markers.\n");
		rules.append("------------------------------------------\n\n");
		return rules.toString();
	}

	public static boolean isTextFile(java.io.File file) {
		if (file.isDirectory()) { return false; }
		String name = file.getName().toLowerCase();
		return name.endsWith(".txt") || name.endsWith(".java") || name.endsWith(".md")
				|| name.endsWith(".log") || name.endsWith(".xml") || name.endsWith(".json")
				|| name.endsWith(".csv") || name.endsWith(".html") || name.endsWith(".css")
				|| name.endsWith(".js") || name.endsWith(".properties");
		// Add more text file extensions as needed
	}

	public static enum DirectoryElementType {
		TEXT_FILE(LineType.FILE_NAME.prefix),
		DIRECTORY(LineType.DIRECTORY_NAME.prefix),
		NOTTEXT("ntf:");

		private final String prefix;

		DirectoryElementType(String prefix) { this.prefix = prefix; }

		public String getPrefix() { return prefix; }
	}

    public static enum LineType {
    	TEXT("TL  "),
    	FILE_NAME("FN: "),
    	FILE_END("Fend"),
    	DIRECTORY_NAME("DN: "),
    	DIRECTORY_END("Dend");

    	private final String prefix;

    	LineType(String prefix) { this.prefix = prefix; }

    	public String getPrefix() { return prefix; }
    }
	
	public static class DirectoryDataAsTextLineData {
		public String line; public LineType type;
		public DirectoryDataAsTextLineData(String line, LineType type) {
			this.line = line; this.type = type;
		}
	}
	
	public static interface DirectoryElement {
		DirectoryDataAsTextLineData[] toLines();
		DirectoryElementType getType();
		String getName();
	}

	// Inside DirectoryToText class as a static nested class
	public static class TextFileElement implements DirectoryElement {
		private final java.io.File file;

		public TextFileElement(java.io.File file) {
			if (file == null || !file.isFile()) {
				throw new IllegalArgumentException("File must not be null and must be a file.");
			}
			this.file = file;
		}

		@Override
		public DirectoryDataAsTextLineData[] toLines() {
			ArrayList<DirectoryDataAsTextLineData> lines = new ArrayList<>();
			try {
				lines.add(new DirectoryDataAsTextLineData(LineType.FILE_NAME.prefix + getName(), LineType.FILE_NAME));
				// Read all lines from the file
				for (String line : java.nio.file.Files.readAllLines(file.toPath())) {
					lines.add(new DirectoryDataAsTextLineData("\t"+line, LineType.TEXT));
				}
				lines.add(new DirectoryDataAsTextLineData(LineType.FILE_END.prefix, LineType.FILE_END)); // Indicate end of file
			} catch (java.io.IOException e) {
				// In case of an error reading, just log it and add an error line
				System.err.println("Error reading text file " + file.getAbsolutePath() + ": " + e.getMessage());
				lines.add(new DirectoryDataAsTextLineData(
						LineType.FILE_END.prefix + "ERROR: Could not read file content.", LineType.FILE_END));
			}
			return lines.toArray(new DirectoryDataAsTextLineData[0]);
		}
		@Override
		public DirectoryElementType getType() { return DirectoryElementType.TEXT_FILE; }
		@Override
		public String getName() { return file.getName()+":"; }
	}
	
	// Inside DirectoryToText class as a static nested class
	public static class NonTextFileElement implements DirectoryElement {
		private final java.io.File file;

		public NonTextFileElement(java.io.File file) {
			if (file == null || !file.isFile()) {
				throw new IllegalArgumentException("File must not be null and must be a file.");
			}
			this.file = file;
		}
		@Override
		public DirectoryDataAsTextLineData[] toLines() {
			return new DirectoryDataAsTextLineData[] {
					new DirectoryDataAsTextLineData(LineType.FILE_NAME.prefix + getName(), LineType.FILE_NAME),
					new DirectoryDataAsTextLineData(LineType.FILE_END.prefix, LineType.FILE_END)
					};
		}
		@Override
		public DirectoryElementType getType() {
			return DirectoryElementType.NOTTEXT;
		}
	    @Override
	    public String getName() { return file.getName()+";"; }
	}
	
	public static class FileDirectory implements DirectoryElement {
		private final java.io.File directory;
		
		public FileDirectory(java.io.File directory) {
			if (directory == null || !directory.isDirectory()) {
				throw new IllegalArgumentException("Directory must not be null and must be a directory.");
			}
			this.directory = directory;
		}
		
		public DirectoryElement[] getDirectoryElements() {
			java.io.File[] files = directory.listFiles();
			if (files == null) {
				// Handle cases where directory is not accessible or doesn't exist
				System.err.println("Could not list contents of directory: " + directory.getAbsolutePath());
				return new DirectoryElement[0];
			}

			ArrayList<DirectoryElement> elements = new ArrayList<>();
			for (java.io.File file : files) {
				if (file.isDirectory()) {
					elements.add(new FileDirectory(file)); // Recursive call for sub-directories
				} else {
					if (isTextFile(file)) {
						elements.add(new TextFileElement(file));
					} else {
						elements.add(new NonTextFileElement(file));
					}
				}
			}

			// Sort the elements alphabetically by name
			elements.sort(java.util.Comparator.comparing(DirectoryElement::getName));

			return elements.toArray(new DirectoryElement[0]);
	    }
		
		public DirectoryDataAsTextLineData[] toLines() {
			ArrayList<DirectoryDataAsTextLineData> result = new ArrayList<DirectoryDataAsTextLineData>();
			result.add(new DirectoryDataAsTextLineData(LineType.DIRECTORY_NAME.prefix + getName(), LineType.DIRECTORY_NAME));
			DirectoryElement[] des = getDirectoryElements();
			for(DirectoryElement de : des) {
				for(DirectoryDataAsTextLineData ld : de.toLines()) {
					ld.line = "\t" + ld.line;
					result.add(ld);
				}
			}
			result.add(new DirectoryDataAsTextLineData(LineType.DIRECTORY_END.prefix, LineType.DIRECTORY_END));
			return result.toArray(new DirectoryDataAsTextLineData[0]);
		}

		@Override
		public DirectoryElementType getType() { return DirectoryElementType.DIRECTORY; }

		@Override
		public String getName() { return directory.getName()+":"; }
		
	}
	

	public static void main(String[] args) {
		JFileChooser fc = new JFileChooser();
		fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

		switch (fc.showDialog(null, "Select Directory to Scan")) {
			case JFileChooser.CANCEL_OPTION:
			case JFileChooser.ERROR_OPTION:
				System.out.println("Directory selection cancelled or error occurred.");
				return;
			case JFileChooser.APPROVE_OPTION:
				File selectedDirectory = fc.getSelectedFile();
				if (selectedDirectory != null && selectedDirectory.isDirectory()) {
					System.out.println("Selected directory: " + selectedDirectory.getAbsolutePath());

					// Create the root Directory object
					FileDirectory rootDirectory = new FileDirectory(selectedDirectory);

					// Collect all lines of output
					DirectoryDataAsTextLineData[] allOutputLines = rootDirectory.toLines();

					// Determine the output file path
					// Using the directory's absolute path and appending a .txt extension
					Path outputPath = Paths.get(selectedDirectory.getAbsolutePath() + ".txt");

					try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputPath.toFile()))) {
						writer.write(getFormattingRules());
						for (DirectoryDataAsTextLineData data : allOutputLines) {
							writer.write(data.type.getPrefix() + data.line); // Add prefix and content
							writer.newLine(); // Write a new line character
						}
						System.out.println("Scan complete. Output written to: " + outputPath.toAbsolutePath());
					} catch (IOException e) {
						System.err.println("Error writing output file: " + e.getMessage());
						e.printStackTrace();
					}
					JOptionPane.showMessageDialog(null, "Complete!");
				} else {
					System.out.println("No valid directory selected.");
				}
				break;
		}
    }

}
